# %%
import pickle

import numpy as np

from PyCO2SYS import CO2System


def test_v1_v2():
    # Import pyco2.sys calculations generated by setup_test_v1_v2.py
    with open("tests/data/test_v1_v2.pkl", "rb") as f:
        results = pickle.load(f)
    # Solve the system with the v2 approach
    co2s = CO2System(
        **{
            k: results[k]
            for k in [
                "alkalinity",
                "dic",
                "salinity",
                "temperature",
                "pressure",
                "total_phosphate",
                "total_silicate",
                "total_ammonia",
                "total_sulfide",
                "pressure_atmosphere",
            ]
        },
        opt_k_carbonic=10,
    )
    co2s.solve()
    # These values don't need to be compared because they weren't output by v1
    dont_compare = [
        "H",
        "factor_k_CO2",
        "k_H3PO4_sws_1atm",
        "factor_k_HPO4",
        "factor_k_Si",
        "k_CO2_1atm",
        "k_HPO4_sws_1atm",
        "ionic_strength",
        "factor_k_H2CO3",
        "factor_k_H3PO4",
        "factor_k_H2O",
        "k_HPO4_sws",
        "factor_k_HCO3",
        "k_NH3_total_1atm",
        "factor_k_H2PO4",
        "factor_k_HSO4",
        "factor_k_HF",
        "k_H2CO3_total_1atm",
        "k_H2PO4_sws_1atm",
        "k_H2O_sws_1atm",
        "k_Si_sws_1atm",
        "k_H2S_total_1atm",
        "factor_k_NH3",
        "factor_k_BOH3",
        "nbs_to_sws",
        "k_HCO3_total_1atm",
        "factor_k_H2S",
        "k_H3PO4_sws",
        "k_BOH3_total_1atm",
        "k_HSO4_free_1atm",
        "k_HF_free_1atm",
        "k_H2O_sws",
        "free_to_sws_1atm",
        "k_H2PO4_sws",
        "k_Si_sws",
        "sws_to_opt",
        "opt_to_sws",
        "tot_to_sws_1atm",
        "opt_to_nbs",
        "opt_to_free",
        "k_HCO3_sws_1atm",
        "k_H2S_sws_1atm",
        "k_NH3_sws_1atm",
        "k_NH3_sws",
        "k_H2CO3_sws_1atm",
        "k_H2CO3_sws",
        "k_BOH3_sws_1atm",
        "k_HCO3_sws",
        "k_BOH3_sws",
        "k_H2S_sws",
        "d_dic__d_pH__alkalinity",
        "d_CO3__d_pH__dic",
        "d_fCO2__d_pH__alkalinity",
        "d_lnCO2__d_pH__dic",
        "d_CO3__d_pH__alkalinity",
        "d_dic__d_pH__fCO2",
        "d_lnCO2__d_pH__alkalinity",
        "d_alkalinity__d_pH__dic",
        "d_lnOmega__d_CO3",
        "d_alkalinity__d_pH__fCO2",
        "Mg_percent",
        "Mg",
        "acf_Ca",
        "acf_Mg",
        "acf_CO3",
        "k_Mg_calcite",
        "saturation_Mg_calcite",
        "total_nitrite",
        "HNO2",
        "NO2",
        "kt_Mg_calcite_25C_1atm_minprep",
        "kt_Mg_calcite_25C_1atm_biogenic",
        "kt_Mg_calcite_25C_1atm_synthetic",
        "kt_Mg_calcite_1atm_vantHoff",
        "kt_Mg_calcite_1atm_PB82",
        "kt_Mg_calcite_1atm_idealmix",
        "pk_HNO2",
    ]
    # This converts keys for values that have a different name in v1 and v2
    v2_to_v1 = {
        "Ca": "total_calcium",
        "gamma_alkalinity": "gamma_alk",
        "beta_alkalinity": "beta_alk",
        "omega_alkalinity": "omega_alk",
        "Q_isocap": "isocapnic_quotient",
        "Q_isocap_approx": "isocapnic_quotient_approx",
        "H_free": "Hfree",
        "pk_H2CO3": "k_carbonic_1",
        "pk_HCO3": "k_carbonic_2",
        "pk_H2O": "k_water",
        "pk_BOH3": "k_borate",
        "pk_HSO4_free": "k_bisulfate",
        "pk_HF_free": "k_fluoride",
        "pk_H3PO4": "k_phosphoric_1",
        "pk_H2PO4": "k_phosphoric_2",
        "pk_HPO4": "k_phosphoric_3",
        "pk_Si": "k_silicate",
        "pk_NH3": "k_ammonia",
        "pk_H2S": "k_sulfide",
        "pk_CO2": "k_CO2",
        "pk_aragonite": "k_aragonite",
        "pk_calcite": "k_calcite",
    }
    # These are keys in the pyco2.sys that are no longer in sys.values
    results_keys = [
        k
        for k in results.keys()
        if not k.startswith("opt_")
        and not k.startswith("alkalinity_")
        and not k.startswith("par1")
        and not k.startswith("par2")
        and not k.endswith("_alpha")
        and not k.endswith("_beta")
        and not k.endswith("out")
        and k
        not in [
            "peng_correction",
            "bicarbonate",
            "carbonate",
            "aqueous_CO2",
            "hydroxide",
            "hydrogen_free",
            "alpha",
            "alphaH",
            "beta",
            "betaH",
            "bh_upsilon",
        ]
    ]
    # Test the values that can be output as standard from a CO2System
    for k, v in co2s.items():
        if k in results:
            # These ones have the same name in v1 and v2
            a = results[k]
            b = co2s[k]
            if k in ["beta_dic", "gamma_dic", "omega_dic"]:
                # These ones have NaNs in different places in v1 and v2, which makes
                # allclose fail, so we need to make the NaNs match first
                a = a.copy()
                b = b.copy()
                L = np.isnan(a) | np.isnan(b)
                a[L] = np.nan
                b[L] = np.nan
            assert np.allclose(a, b, atol=0, rtol=1e-7, equal_nan=True), k
            results_keys.remove(k)
        elif k in v2_to_v1:
            # These ones have a different name in v1 vs v2
            if k.startswith("pk_"):
                v = 10**-v
            assert np.allclose(
                results[v2_to_v1[k]], v, atol=0, rtol=1e-7, equal_nan=True
            ), k
            results_keys.remove(v2_to_v1[k])
        elif k not in dont_compare:
            # All the others should be in the dont_compare list
            assert False, k
    # Also test the edge cases (gradients of fCO2 and pCO2 w.r.t. temperature) that have
    # to be calculated manually for a CO2System
    for k in results_keys.copy():
        if k == "dlnfCO2_dT":
            co2s.get_grad("fCO2", "temperature")
            v = co2s.grads["fCO2"]["temperature"] / co2s["fCO2"]
            assert np.allclose(results[k], v, atol=0, rtol=1e-7, equal_nan=True), k
            results_keys.remove(k)
        elif k == "dlnpCO2_dT":
            co2s.get_grad("pCO2", "temperature")
            v = co2s.grads["pCO2"]["temperature"] / co2s["pCO2"]
            assert np.allclose(results[k], v, atol=0, rtol=1e-7, equal_nan=True), k
            results_keys.remove(k)
        else:
            # There shouldn't be anything else left in results_keys
            assert False, k


# test_v1_v2()
